#/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Mon Sep 18 09:26:41 2023@author: ranjiths"""from pythtb import *import matplotlib. pyplot as pltimport numpy as npimport matplotlib# a 1D model # The lattice vector a_i. Since we are in 1D only one component is sufficient.# the origin of the lattice vector is considered to be (0, 0)lattice_vectors = [[1.0, 0.0], [0.0, 1.0]]# Incase of 2D each item in the list is a 2 component vector #denoting the x and y coordinate of the lattice vector# the the list contains as many items(vectors) as that of the dimensions of the model# the  position of each orbital within the unit cell. aka the basis vectors# denoted by a  numbers [m] such that the corresponding orbital is given by m*a_1orbital = [[0.0, 0.0], [0.5, 0.5]]# incase of 2d each item in the list is a 2 component vector.my_model = tb_model(2, 2, lattice_vectors, orbital) # spin default = 1 spinless#A model is created by spcifying the k_space dimensions, real-space dimensions,#the real space lattice lattice vectors and the orbital positions.delta=1.1t=0.6# set on-site energiesmy_model.set_onsite([-delta,delta])# set hoppings (one for each connected pair of orbitals)# (amplitude, i, j, [lattice vector to cell containing j])my_model.set_hop(t, 1, 0, [0, 0])my_model.set_hop(t, 1, 0, [1, 0])my_model.set_hop(t, 1, 0, [0, 1])my_model.set_hop(t, 1, 0, [1, 1])#The hopping term needs to be specified for each interaction. #( hopping_amplitude, index i of the orbital in the unit cell,# index j of the orbital in a different unit cell, #the R vector interms of [m,n] of lattice vector connecting the cell containing# i ( origin) and the cell containing j)# =============================================================================# The Model is complete - Now we need to extract information out of this model# =============================================================================my_model.display() # used to show the parameters in the model(fig, ax) = my_model.visualize(1, 0)# the two parameters denote the orientation of the first lattice vector #with respect to the plotting coordinate# only the interactions of the orbitals within the first unit cell are shown# with both within and outside the unit cell orbitals. # To visualize the interactions among the orbitals.path = [[0, 0], [0, 0.5], [0.5, 0.5], [0, 0], [0.5, 0], [0.5, 0.5]](k_vec, k_dist, k_node) = my_model.k_path(path, 300)k_label = [r"$\Gamma$", r'$X$', r"$M$",  r"$\Gamma$", r"$Y$", r"$M$" ]# #'fullc' denotes [-0.5, 0, 0.5 ] of the Brillouin zone in 1D This is special only for 1Devals=my_model.solve_all(k_vec)# plot band structurefig, ax = plt.subplots()for i in range(len(evals)):    ax.plot(k_dist,evals[i]) # This will plot only one band#This is sufficient since there is only one orbital in the unit cell.ax.set_title("1D chain band structure")ax.set_xlabel("Path in k-space")ax.set_ylabel("Band energy")ax.set_xticks(k_node)ax.set_xticklabels(k_label)ax.set_xlim(k_node[0],k_node[-1])for n in range(len(k_node)):  ax.axvline(x=k_node[n], linewidth=0.5, color='k')fig.tight_layout()